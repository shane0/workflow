# -*- coding: utf-8 -*-
import os
"""click cucumber

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kNU7vTKStv_1XXhWvqnq9KRSWuHAvH0-
"""

# prompt: function that
# has a parameter for  folder name
# returns a list of folders in the given folder
# add sample test

import os

def list_folders(folder_name):
  """
  Lists all folders within a given folder.

  Args:
    folder_name: The path to the folder.

  Returns:
    A list of folder names within the specified folder, or an empty list if the folder does not exist or contains no subfolders.
    Returns None if input is invalid.
  """
  if not isinstance(folder_name, str) or not folder_name:
    return None

  if not os.path.isdir(folder_name):
    return []

  folders = []
  for item in os.listdir(folder_name):
    item_path = os.path.join(folder_name, item)
    if os.path.isdir(item_path):
      folders.append(item)
  return folders


# Sample test cases
def test_list_folders():
  # Test case 1: Valid folder
  test_folder = "test_folder"
  os.makedirs(test_folder, exist_ok=True)  # Create the test folder if it doesn't exist
  os.makedirs(os.path.join(test_folder, "subfolder1"), exist_ok=True)
  os.makedirs(os.path.join(test_folder, "subfolder2"), exist_ok=True)

  folders = list_folders(test_folder)
  assert folders == ["subfolder1", "subfolder2"], f"Expected ['subfolder1', 'subfolder2'], but got {folders}"

  #clean up test folder
  # !rm -rf test_folder

  # Test case 2: Non-existent folder
  folders = list_folders("non_existent_folder")
  assert folders == [], f"Expected [], but got {folders}"

  # Test case 3: Empty folder
  os.makedirs("empty_folder", exist_ok=True)
  folders = list_folders("empty_folder")
  assert folders == [], f"Expected [], but got {folders}"
  # !rm -rf empty_folder

  # Test case 4: Invalid input
  result = list_folders(123)
  assert result is None, f"Expected None, but got {result}"

  result = list_folders("")
  assert result is None, f"Expected None, but got {result}"

# test_list_folders()
# print("All test cases passed!")

"""function that
has a parameter for  folder name
returns a list of folders in the given folder
add a sample test
"""

# prompt: function that
# has a parameter for  folder name
# returns a list of folders in the given folder
# add a sample test



def list_folders(folder_name):
  """
  Lists all folders within a given folder.

  Args:
    folder_name: The path to the folder.

  Returns:
    A list of folder names within the specified folder, or an empty list if the folder does not exist or contains no subfolders.
    Returns None if input is invalid.
  """
  if not isinstance(folder_name, str) or not folder_name:
    return None

  if not os.path.isdir(folder_name):
    return []

  folders = []
  for item in os.listdir(folder_name):
    item_path = os.path.join(folder_name, item)
    if os.path.isdir(item_path):
      folders.append(item)
  return folders

"""
function that
has a parameter for folder name
has a parameter for file extension
returns lists with the files in the folder that match the extension
add a sample test


"""

# prompt: function that
# has a parameter for folder name
# has a parameter for file extension
# returns lists with the files in the folder that match the extension
# add a sample tes

import os

def list_files_with_extension(folder_name, file_extension):
    """
    Lists files with a specific extension within a given folder.

    Args:
        folder_name: The path to the folder.
        file_extension: The file extension to search for (e.g., ".txt", ".pdf").

    Returns:
        A list of file names with the specified extension within the folder,
        or an empty list if the folder does not exist, contains no files with the extension,
        or if the inputs are invalid.
        Returns None if input folder_name is invalid.
    """
    if not isinstance(folder_name, str) or not folder_name:
        return None

    if not isinstance(file_extension, str) or not file_extension:
        return []

    if not os.path.isdir(folder_name):
        return []

    files = []
    for item in os.listdir(folder_name):
        if item.endswith(file_extension):
            files.append(item)
    return files

# Sample Test Cases
def test_list_files_with_extension():
    # Test case 1: Valid folder and extension
    test_folder = "test_folder"
    os.makedirs(test_folder, exist_ok=True)
    with open(os.path.join(test_folder, "file1.txt"), "w") as f:
        f.write("test")
    with open(os.path.join(test_folder, "file2.txt"), "w") as f:
        f.write("test")
    with open(os.path.join(test_folder, "file3.pdf"), "w") as f:
        f.write("test")

    files = list_files_with_extension(test_folder, ".txt")
    assert files == ["file1.txt", "file2.txt"], f"Expected ['file1.txt', 'file2.txt'], but got {files}"

    #clean up test folder
    # !rm -rf test_folder

    # Test case 2: Invalid folder
    files = list_files_with_extension("non_existent_folder", ".txt")
    assert files == [], f"Expected [], but got {files}"

    # Test case 3: Empty folder
    os.makedirs("empty_folder", exist_ok=True)
    files = list_files_with_extension("empty_folder", ".txt")
    assert files == [], f"Expected [], but got {files}"
    # !rm -rf empty_folder

    # Test case 4: Invalid input
    result = list_files_with_extension(123, ".txt")
    assert result is None, f"Expected None, but got {result}"

    result = list_files_with_extension("", ".txt")
    assert result is None, f"Expected None, but got {result}"

    result = list_files_with_extension("valid_folder", 123)
    assert result == [], f"Expected [], but got {result}"

# test_list_files_with_extension()
# print("All test cases passed!")

"""
function that
has a parameter for a list
prompts the user to choose one by number
returns the list item selected
add a sample test
"""

# prompt: function that
# has a parameter for a list
# prompts the user to choose one by number
# returns the list item selected
# add a sample test

import os

def choose_from_list(items):
  """
  Prompts the user to choose an item from a list by number.

  Args:
    items: A list of items.

  Returns:
    The selected item from the list, or None if the input is invalid or the choice is out of range.
  """
  if not isinstance(items, list) or not items:
    return None

  for i, item in enumerate(items):
    print(f"{i + 1}. {item}")

  while True:
    try:
      choice = int(input("Enter your choice: "))
      if 1 <= choice <= len(items):
        return items[choice - 1]
      else:
        print("Invalid choice. Please enter a number within the valid range.")
    except ValueError:
      print("Invalid input. Please enter a number.")


# Sample Test
def test_choose_from_list():
    # Test case 1: Valid list
    items = ["apple", "banana", "cherry"]
    selected_item = choose_from_list(items)
    assert selected_item in items, f"Selected item '{selected_item}' not found in the list."

    #Test case 2: Empty List
    selected_item = choose_from_list([])
    assert selected_item is None

    # Test case 3: Invalid input
    selected_item = choose_from_list(123)
    assert selected_item is None

# test_choose_from_list()
# print("All test cases passed!")

# prompt: function that
# has a parameter for a bash command
# runs the bash command
# add a sample test

import subprocess

def run_bash_command(command):
  """Runs a bash command and returns the output."""
  try:
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    if stderr:
      print(f"Error executing command: {stderr.decode()}")
      return None
    return stdout.decode()
  except FileNotFoundError:
    print(f"Error: Command not found.")
    return None
  except Exception as e:
      print(f"An unexpected error occurred: {e}")
      return None

def test_run_bash_command():
    # Test case 1: Valid command
    output = run_bash_command("ls -l")
    assert output is not None, "Output should not be None for a valid command."

    # Test case 2: Invalid command
    output = run_bash_command("invalid_command")
    assert output is None, "Output should be None for an invalid command."

# test_run_bash_command()
# print("All test cases passed!")

"""function that
has a parameter for a bash command
runs the bash command
add a sample test

how to return only the value given a list item
"""

# prompt: how to return only the value given a list item

def get_list_item_value(items, index):
    """
    Returns the value of a list item at a given index.

    Args:
        items: The list of items.
        index: The index of the item to retrieve.

    Returns:
        The value of the list item at the specified index, or None if the index is out of range or the input is invalid.
    """
    if not isinstance(items, list):
        return None

    if not isinstance(index, int) or index < 0 or index >= len(items):
        return None

    return items[index]

# Sample Test
def test_get_list_item_value():
    # Test case 1: Valid list and index
    items = ["apple", "banana", "cherry"]
    value = get_list_item_value(items, 1)
    print(value)
    assert value == "banana", f"Expected 'banana', but got {value}"

    # Test case 2: Invalid index
    value = get_list_item_value(items, 5)  # index out of range
    print(value)
    assert value is None, f"Expected None, but got {value}"

    # Test case 3: Invalid input (not a list)
    value = get_list_item_value("not a list", 0)
    print(value)
    assert value is None, f"Expected None, but got {value}"

    # Test case 4: Negative index
    value = get_list_item_value(items, -1)
    print(value)
    assert value is None, f"Expected None, but got {value}"

# test_get_list_item_value()
# print("All test cases passed!")